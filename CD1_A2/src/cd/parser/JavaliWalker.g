/**************************************************************************************************
 *   JAVALI TREE GRAMMAR
 *   Compiler Construction I
 *
 *   ABOUT:
 *   -------
 *   
 *   A tree grammar takes as input the ANTLR AST generated by the rewriting rules of the parser grammar
 *   and generates a visitor that visits the ANTLR AST and issues the action code associated with the tree
 *   grammar rule. We use the tree grammar for generating the Javali AST (i.e., AST whose nodes are
 *   instances of cd.ir.Ast.java). Thus, we invoke the appropriate Javali AST constructors in the action
 *   code associated with the tree grammar rules.
 *
 *   The rewriting rules of the parser grammar are a good starting point for generating the tree grammar.
 *   The easiest way to generate a tree grammar is to start with the parser grammar (copy & paste) and to
 *   remove the grammar productions (left side of arrow), leaving only the rewriting rules (right side of arrow).
 *   Note, however, that the rewriting rules may have to be changed. For instance, imaginary tokens need no
 *   longer to be created, but can simply be referenced (i.e., brackets with token binding must be omitted).
 *   Also, variables must be replaced with the actual node that is visited. Most likely, the tree grammar
 *   will also become more condensed than the parser grammar since it can expect the parser grammar
 *   to pass on valid ANTLR ASTs only. For instance, the tree grammar does not need to encode
 *   operator precedences.
 *
**************************************************************************************************/

tree grammar JavaliWalker; // tree grammar, parses streams of nodes

// (1) OPTIONS
options {   
	tokenVocab=Javali; // uses tokens defined in Javali.g
	ASTLabelType=CommonTree;
}

// (2) ACTIONS
@header {
package cd.parser; // include any import statements that are required by your action code

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

import cd.ir.Ast;
import cd.ir.Ast.*;

import cd.util.Pair;

import cd.exceptions.ParseFailure;
}

@members { // incude any members that are required by your action code

	public <T> List<T> emptyList() {
		return java.util.Collections.emptyList();
	}
    
	public Seq seq(List<? extends Ast>... members) {
		Seq res = new Seq(null);
		if (members != null) {
			for (List<? extends Ast> lst : members)
				res.rwChildren().addAll(lst);
		}
		return res;
	}

	public Integer intValue(String s, int radix, int line) {
		try {
			return Integer.valueOf(s, radix);
		} catch (NumberFormatException e) {
			throw new ParseFailure(line, "Illegal integer: " + s);
		}
	}
	
	public Float floatValue(String s, int line) {
		try {
			return Float.valueOf(s);
		} catch (NumberFormatException e) {
			throw new ParseFailure(line, "Illegal float: " + s);
		}
	}
}

// (3) TREE GRAMMAR RULES
// TODO: specify tree grammar rules and action code...
unit returns [List<ClassDecl> classDeclList]	
   @init {
      $classDeclList = new ArrayList<ClassDecl>();
   }
   
	: (a=classDecl  {$classDeclList.add($a.classDecl);} )+
;

classDecl returns [ClassDecl classDecl]
   @init {
      List<Ast> dList = new ArrayList<Ast>();
   }
	: ^(ClassDecl name=Identifier extend=Identifier (list=declList { dList = $list.value;} )?)
	{
		$classDecl = new ClassDecl($name.text, $extend.text, dList);
	}
;

declList returns [List<Ast> value]
@init {
     $value = new ArrayList<Ast>();
   }
	: ^(DeclList ( v=varOrMethodDecl { $value.add($v.value); })+)
; 

varOrMethodDecl returns [Ast value]
	: ( a=varDecl {$value = $a.value;}| a=methodDecl {$value = $a.value;})
; 

varDecl returns [Ast value]
	: ^(VarDecl t=Type id=Identifier) 
	{
		$value = new VarDecl($t.text, $id.text);
	}
;

methodDecl returns [Ast value]
	: ^(MethodDecl a=methodHeading b=methodBody)
	{
		$value = new MethodDecl($a.retType, $a.name, $a.paramList, $b.declSeq, $b.stmtSeq);
	}	 		//MethodDecl {$value = new MethodDecl("atype",  "aname",  new ArrayList<Pair<String>>(),  null, null); }   //^(MethodDecl methodHeading methodBody)
	;
	
methodHeading returns [String name, String retType,  List<Pair<String>> paramList]
@init {
     $paramList = new ArrayList<Pair<String>>() ;
   }
	: (t=Type n=Identifier (l=formalParamList {$paramList = $l.paramList; } )?) {$name = $n.text; $retType = $t.text; } 
	| ('void' n=Identifier (l=formalParamList {$paramList = $l.paramList; } )?) {$name = $n.text; $retType = "void"; } 
	;

formalParamList returns [List<Pair<String>> paramList] 
@init {
     $paramList = new ArrayList<Pair<String>>() ;
   }
	: (^(VarDecl t=Type id2=Identifier { $paramList.add(new Pair<String>($t.text,$id2.text)); } ))+ 
	;

methodBody returns [ Seq declSeq, Seq stmtSeq ]
@init {
     $declSeq = new Seq(null);  
     $stmtSeq = new Seq(null); 
   } 
   	: ^(MethodBody ((a=declList  {$declSeq = new Seq($a.value); } )?) ((b=stmtList { $stmtSeq = new Seq($b.value); })?)  ) 
	;
	
stmtList returns [List<Ast> value]
@init {
     $value = new ArrayList<Ast>(); 
   }
	: ^(Seq (a=stmt { $value.add($a.value); } )*) 
	; 
	
stmt returns [Ast value]
	:	a=ioStmt {$value = $a.value;}
	|	^(Assign id=identAccess r=assignmentRHS) {$value = new Assign($id.value, $r.value); }
	|	e=identAccessStmt {$value = $e.value;}
	|	b=ifStmt {$value = $b.value; }
	|	c=whileStmt {$value = $c.value;}
	|	d=returnStmt {$value = $d.value;}
	; 
	 
ioStmt returns[Ast value]
	: 	^(BuiltInWrite a=expr) {$value = new BuiltInWrite($a.value);} 
	| 	^(BuiltInWriteFloat a=expr) {$value = new BuiltInWriteFloat($a.value);}
   	| 	BuiltInWriteln {$value = new BuiltInWriteln();}
   	;
   	
ifStmt returns[Ast value] 
	:	^(IfElse e=expr fst=stmtList snd=stmtList) { $value = new IfElse($e.value, new Seq($fst.value), new Seq($snd.value));}
	|	^(IfStmt e=expr fst=stmtList) { $value = new IfElse($e.value, new Seq($fst.value), new Nop());} 
	; 
	
whileStmt returns[Ast value]
	: ^(WhileLoop a=expr b=stmtList ) {$value = new WhileLoop($a.value, new Seq($b.value));}
	;
	
returnStmt returns[Ast value]
	: ^(ReturnStmt a=expr?){ 
		if (a==null){ 
			$value = new ReturnStmt(null);
		} else {
			$value = new ReturnStmt($a.value);
		}
	}
	;
	 
identAccess returns [Expr value]
   	:	(
   			^(Var i=Identifier{$value = new Var($i.text); })
   			| ^(MethodCall i=Identifier args=methodCallTail {$value = new MethodCallExpr(new ThisRef(), $i.text, $args.value); })
   			| ThisRef {$value = new ThisRef();}
   		)
   		(
   			^(SelectorField a=Identifier) {$value = new Field($value, $a.text); } 
   			| ^(SelectorMethod a=Identifier b=methodCallTail) {$value = new MethodCallExpr($value, $a.text, $b.value); } 
   			| ^(SelectorArray q=expr) {$value = new Index($value,$q.value); }
   		)* 
   	;
   	
identAccessStmt returns [Ast value]
@init {
     Expr last = null; 
   }
   	:	(
   			^(Var i=Identifier{last = new Var($i.text); })
   			| ^(MethodCall i=Identifier args=methodCallTail { $value = new MethodCall(new ThisRef(), $i.text, $args.value);
   				last = new MethodCallExpr(new ThisRef(), $i.text, $args.value); })
   			| ThisRef {last = new ThisRef();}
   		)
   		(
   			^(SelectorField a=Identifier) {last = new Field(last, $a.text); } 
   			| ^(SelectorMethod a=Identifier b=methodCallTail) { $value = new MethodCall(last, $a.text, $b.value);
   				last = new MethodCallExpr(last, $a.text, $b.value); } 
   			| ^(SelectorArray q=expr) {last = new Index(last,$q.value); }
   		)*  
   	;
   	
methodCallTail returns [List<Expr> value] 
@init { 
     $value = new ArrayList<Expr>();
   }
	:	^(Seq (a=expr {$value.add($a.value); })*)
	;
	
assignmentRHS returns [Expr value]
	:	a=expr {$value = $a.value;}
	|	a=newExpr {$value = $a.value;}
	|	a=readExpr {$value = $a.value;}
	|	a=readExprFloat {$value = $a.value;}
	;

expr returns[Expr value]   
	: 	^(B_Op a=expr compOperator=binOp b = expr) { $value = new BinaryOp($a.value, $compOperator.value, $b.value); } 
	|	^(U_PLUS a=expr) {$value = new UnaryOp(UnaryOp.UOp.U_PLUS, $a.value);}
	|	^(U_MINUS a=expr) {$value = new UnaryOp(UnaryOp.UOp.U_MINUS, $a.value);}
	|	^(U_BOOL_NOT a=expr) {$value = new UnaryOp(UnaryOp.UOp.U_BOOL_NOT, $a.value);}
	|	(a=identAccess) {$value = $a.value; }
	|	NullConst { $value = new NullConst(); } 
	|	^(Cast ^(RefType c=Identifier) b=expr) { $value = new Cast($b.value, $c.text);} 
	|	^(DecimalIntConst d=DecimalNumber) {$value = new IntConst(intValue($d.text,10,$d.getLine()));}
	|	^(HexIntConst d=HexNumber) {$value = new IntConst(intValue($d.text.substring(2,$d.text.length()),16,$d.getLine()));}
	|	^(FloatConst d=FloatNumber) {$value = new FloatConst(floatValue($d.text ,$d.getLine()));}
	|	^(BooleanConst d=BooleanLiteral) {
			if ($d.text.equals("true")) {
				$value = new BooleanConst(true);
			} else {
				$value = new BooleanConst(false);
			}
		}
	; 
	
binOp returns[BinaryOp.BOp value]
	:	B_EQUAL {$value=BinaryOp.BOp.B_EQUAL;}
	|	B_NOT_EQUAL {$value=BinaryOp.BOp.B_NOT_EQUAL;}
	|	B_LESS_THAN {$value=BinaryOp.BOp.B_LESS_THAN;}
	|  	B_LESS_OR_EQUAL {$value=BinaryOp.BOp.B_LESS_OR_EQUAL;}
	|	B_GREATER_THAN {$value=BinaryOp.BOp.B_GREATER_THAN;}
	|	B_GREATER_OR_EQUAL {$value=BinaryOp.BOp.B_GREATER_OR_EQUAL;}
	|	B_TIMES{$value=BinaryOp.BOp.B_TIMES;}
	|	B_DIV{$value=BinaryOp.BOp.B_DIV;} 
	|	B_MOD{$value=BinaryOp.BOp.B_MOD;}
	|	B_PLUS{$value=BinaryOp.BOp.B_PLUS;}
	|	B_MINUS{$value=BinaryOp.BOp.B_MINUS;}
	|     	B_AND{$value=BinaryOp.BOp.B_AND;}
	|       B_OR{$value=BinaryOp.BOp.B_OR;}        
	;

newExpr returns [Expr value]
	: ^(NewObject a=Identifier) {$value = new NewObject($a.text);}
	| ^(NewArray a=Identifier b=expr) {$value = new NewArray($a.text+"[]", $b.value);}
	;
	
readExpr returns [Expr value]
	: BuiltInRead {$value = new BuiltInRead();}
	;
   
readExprFloat returns [Expr value]
	: BuiltInReadFloat {$value = new BuiltInReadFloat();}
	;
