package cd.codegen;

import static cd.Config.MAIN;
import static cd.Config.SCANF;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import cd.Config;
import cd.Main;
import cd.debug.AstOneLine;
import cd.ir.Ast;
import cd.ir.Ast.Assign;
import cd.ir.Ast.BinaryOp;
import cd.ir.Ast.BooleanConst;
import cd.ir.Ast.BuiltInRead;
import cd.ir.Ast.BuiltInReadFloat;
import cd.ir.Ast.BuiltInWrite;
import cd.ir.Ast.BuiltInWriteFloat;
import cd.ir.Ast.BuiltInWriteln;
import cd.ir.Ast.Cast;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.Expr;
import cd.ir.Ast.Field;
import cd.ir.Ast.FloatConst;
import cd.ir.Ast.IfElse;
import cd.ir.Ast.Index;
import cd.ir.Ast.IntConst;
import cd.ir.Ast.MethodCall;
import cd.ir.Ast.MethodCallExpr;
import cd.ir.Ast.MethodDecl;
import cd.ir.Ast.NewArray;
import cd.ir.Ast.NewObject;
import cd.ir.Ast.NullConst;
import cd.ir.Ast.ReturnStmt;
import cd.ir.Ast.ThisRef;
import cd.ir.Ast.UnaryOp;
import cd.ir.Ast.Var;
import cd.ir.Ast.VarDecl;
import cd.ir.Ast.WhileLoop;
import cd.ir.AstVisitor;
import cd.ir.ExprVisitor;

public class AstCodeGenerator {

	protected final RegsNeededVisitor rnv = new RegsNeededVisitor();
	protected final ExprGenerator eg = new ExprGenerator();
	protected final StmtDeclGenerator sdg = new StmtDeclGenerator();
	protected final Writer out;
	protected final Main main;

	public AstCodeGenerator(Main main, Writer out) {
		initMethodData();
		this.out = out;
		this.main = main;
	}

	public void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	protected static final String VAR_PREFIX = "var_";

	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into three sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrologue()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * <li>Epilogue: Generated by {@link #emitEpilogue()}. This contains any
	 * final declarations required.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		for (ClassDecl ast : astRoots) {
			sdg.gen(ast);
		}
	}

	// Simplistic Register management:
	List<String> registers = new ArrayList<String>();

	final String BP = "%ebp", SP = "%esp";

	protected void initRegisters() {
		registers.clear();
		registers.add("%eax");
		registers.add("%ebx");
		registers.add("%ecx");
		registers.add("%edx");
		registers.add("%esi");
		registers.add("%edi");
	}

	protected String getRegister() {
		int last = registers.size() - 1;
		assert last >= 0 : "Program requires too many registers";
		return registers.remove(last);
	}

	protected void releaseRegister(String reg) {
		assert !registers.contains(reg);
		registers.add(reg);
	}

	protected boolean isInUse(String reg) {
		return !registers.contains(reg);
	}

	protected int availableRegisters() {
		return registers.size();
	}

	protected void initMethodData() {
		initRegisters();
	}
	
	/**
	 * Generates code to evaluate expressions. After emitting the code, returns
	 * a String which indicates the register where the result can be found.
	 */
	protected class ExprGenerator extends ExprVisitor<String, Void> {

		public String gen(Expr ast) {
			return visit(ast, null);
		}

		@Override
		public String visit(Expr ast, Void arg) {

			try {
				emitIndent("Emitting " + AstOneLine.toString(ast));
				return super.visit(ast, null);
			} finally {
				emitUndent();
			}

		}

		@Override
		public String binaryOp(BinaryOp ast, Void arg) {
			int leftRN = rnv.calc(ast.left());
			int rightRN = rnv.calc(ast.right());
			String leftReg, rightReg;
			if (leftRN > rightRN) {
				leftReg = gen(ast.left());
				rightReg = gen(ast.right());
			} else {
				rightReg = gen(ast.right());
				leftReg = gen(ast.left());
			}
			debug("Binary Op: %s (%s,%s)", ast, leftReg, rightReg);
			switch (ast.operator) {
			case B_TIMES:
				emit("imul", rightReg, leftReg);
				break;
			case B_PLUS:
				emit("add", rightReg, leftReg);
				break;
			case B_MINUS:
				emit("sub", rightReg, leftReg);
				break;
			default:
				{
					throw new RuntimeException("Not yet supported");
				}
			}
			releaseRegister(rightReg);
			return leftReg;
		}

		@Override
		public String booleanConst(BooleanConst ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String builtInRead(BuiltInRead ast, Void arg) {
			String reg = getRegister();
			emit("sub", c(16), SP);
			emit("leal", o(8, SP), reg);
			emitStore(reg, 4, SP);
			emitStore("$STR_D", 0, SP);
			emit("call", SCANF);
			emitLoad(8, SP, reg);
			emit("add", c(16), SP);
			return reg;
		}

		@Override
		public String builtInReadFloat(BuiltInReadFloat ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String cast(Cast ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String index(Index ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String intConst(IntConst ast, Void arg) {
			String reg = getRegister();
			emit("movl", "$" + ast.value, reg);
			return reg;
		}

		@Override
		public String floatConst(FloatConst ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String field(Field ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String newArray(NewArray ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String newObject(NewObject ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String nullConst(NullConst ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String thisRef(ThisRef ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String methodCall(MethodCallExpr ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String unaryOp(UnaryOp ast, Void arg) {
			String argReg = gen(ast.arg());
			switch (ast.operator) {
			case U_PLUS:
				break;

			case U_MINUS:
				emit("negl", argReg);
				break;

			case U_BOOL_NOT:
				emit("negl", argReg);
				emit("incl", argReg);
				break;
			}
			return argReg;
		}

		@Override
		public String var(Var ast, Void arg) {
			String reg = getRegister();
			emit("movl", VAR_PREFIX + ast.name, reg);
			return reg;
		}

	}

	/**
	 * Generates code to process statements and declarations.
	 */
	public class StmtDeclGenerator extends AstVisitor<String, Void> {

		public void gen(Ast ast) {
			visit(ast, null);
		}

		@Override
		public String visit(Ast ast, Void arg) {
			try {
				emitIndent("Emitting " + AstOneLine.toString(ast));
				return super.visit(ast, arg);
			} finally {
				emitUndent();
			}
		}
				
		@Override
		public String methodCall(MethodCall ast, Void dummy) {
			throw new RuntimeException("Not required");

		}

		// Emit vtable for arrays of this class:
		@Override
		public String classDecl(ClassDecl ast, Void arg) {
			if (!ast.name.equals("Main"))
				throw new RuntimeException(
						"Only expected one class, named 'main'");
			return visitChildren(ast, arg);
		}

		@Override
		public String methodDecl(MethodDecl ast, Void arg) {
			if (!ast.name.equals("main"))
				throw new RuntimeException(
						"Only expected one method named 'main'");
			// Emit some useful string constants:
			emit(Config.DATA_STR_SECTION);
			emitLabel("STR_NL");
			emit(Config.DOT_STRING + " \"\\n\"");
			emitLabel("STR_D");
			emit(Config.DOT_STRING + " \"%d\"");
			// Emit a label for each variable:
			// Let the AST Visitor do the iteration for us.
			emit(Config.DATA_INT_SECTION);
			ast.decls().accept(new AstVisitor<Void, Void>() {
				@Override
				public Void varDecl(VarDecl ast, Void arg) {
					if (!ast.type.equals("int"))
						throw new RuntimeException(
								"Only int variables expected");
					emitLabel(VAR_PREFIX + ast.name);
					emitConstantData("0");
					return null;
				}
			}, null);
			// Emit the main() method:
			emit(Config.TEXT_SECTION);
			emit(".globl " + MAIN);
			emitLabel(MAIN);
			emit("enter", "$8", "$0");
			emit("and", -16, SP);
			gen(ast.body());
			emitMethodSuffix(true);
			return null;
		}

		@Override
		public String ifElse(IfElse ast, Void arg) {
			throw new RuntimeException("Not required");

		}

		@Override
		public String whileLoop(WhileLoop ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String assign(Assign ast, Void arg) {
			if (!(ast.left() instanceof Var))
				throw new RuntimeException("LHS must be var in A1");
			Var var = (Var) ast.left();
			String rhsReg = eg.gen(ast.right());
			emit("movl", rhsReg, VAR_PREFIX + var.name);
			releaseRegister(rhsReg);
			return null;
		}

		@Override
		public String builtInWrite(BuiltInWrite ast, Void arg) {
			String reg = eg.gen(ast.arg());
			emit("sub", c(16), SP);
			emitStore(reg, 4, SP);
			emitStore("$STR_D", 0, SP);
			emit("call", Config.PRINTF);
			emit("add", c(16), SP);
			releaseRegister(reg);
			return null;
		}

		@Override
		public String builtInWriteFloat(BuiltInWriteFloat ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String builtInWriteln(BuiltInWriteln ast, Void arg) {
			emit("sub", c(16), SP);
			emitStore("$STR_NL", 0, SP);
			emit("call", Config.PRINTF);
			emit("add", c(16), SP);
			return null;
		}

		@Override
		public String returnStmt(ReturnStmt ast, Void arg) {
			throw new RuntimeException("Not required");
		}

	}

	// -------------------------------------------------------
	// EMIT CODE

	private StringBuilder indent = new StringBuilder();

	/** Creates an constant operand relative to another operand. */
	protected String c(int i) {
		return "$" + i;
	}

	/** Creates an constant operand with the address of a label. */
	protected String c(String lbl) {
		return "$" + lbl;
	}

	/** Creates an operand relative to another operand. */
	protected String o(int offset, String reg) {
		return String.format("%d(%s)", offset, reg);
	}

	/** Creates an operand addressing an item in an array */
	protected String a(String arrReg, String idxReg) {
		final int offset = Config.SIZEOF_PTR; // one word in front for vptr
		final int mul = Config.SIZEOF_PTR; // assume all arrays of 4-byte elem
		return String.format("%d(%s,%s,%d)", offset, arrReg, idxReg, mul);
	}

	protected void emitIndent(String comment) {
		this.indent.append("  ");
		if (comment != null)
			emitComment(comment);
	}

	protected void emitCommentSection(String name) {
		int indentLen = this.indent.length();
		int breakLen = 68 - indentLen - name.length();
		StringBuffer sb = new StringBuffer();
		sb.append(Config.COMMENT_SEP).append(" ");
		for (int i = 0; i < indentLen; i++)
			sb.append("_");
		sb.append(name);
		for (int i = 0; i < breakLen; i++)
			sb.append("_");

		try {
			out.write(sb.toString());
			out.write("\n");
		} catch (IOException e) {
		}
	}

	protected void emitComment(String comment) {
		emit(Config.COMMENT_SEP + " " + comment);
	}

	protected void emitUndent() {
		this.indent.setLength(this.indent.length() - 2);
	}

	protected void emit(String op, String src, String dest) {
		emit(String.format("%s %s, %s", op, src, dest));
	}

	public void emit(String op, int src, String dest) {
		emit(op, c(src), dest);
	}

	protected void emit(String op, String dest) {
		emit(op + " " + dest);
	}

	protected void emit(String op, int dest) {
		emit(op, c(dest));
	}

	protected void emitMove(String src, String dest) {
		if (!src.equals(dest))
			emit("movl", src, dest);
	}

	protected void emitLoad(int srcOffset, String src, String dest) {
		emitMove(o(srcOffset, src), dest);
	}

	protected void emitStore(String src, int destOffset, String dest) {
		emitMove(src, o(destOffset, dest));
	}

	protected void emitConstantData(String data) {
		emit(String.format("%s %s", Config.DOT_INT, data));
	}

	private int counter = 0;

	protected String uniqueLabel() {
		String labelName = "label" + counter++;
		return labelName;
	}

	protected void emitLabel(String main) {
		try {
			out.write(main + ":" + "\n");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	protected void emit(String op) {
		try {
			out.write(indent.toString());
			out.write(op);
			out.write("\n");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit("movl", "$0", "%eax");
		emit("leave");
		emit("ret");
	}

}
