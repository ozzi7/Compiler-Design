package cd.codegen;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;

import cd.Config;
import cd.Main;
import cd.debug.AstOneLine;
import cd.exceptions.ToDoException;
import cd.ir.Ast;
import cd.ir.Ast.Assign;
import cd.ir.Ast.BinaryOp;
import cd.ir.Ast.BooleanConst;
import cd.ir.Ast.BuiltInRead;
import cd.ir.Ast.BuiltInWrite;
import cd.ir.Ast.BuiltInWriteln;
import cd.ir.Ast.Cast;
import cd.ir.Ast.ClassDecl;
import cd.ir.Ast.Expr;
import cd.ir.Ast.Field;
import cd.ir.Ast.IfElse;
import cd.ir.Ast.Index;
import cd.ir.Ast.IntConst;
import cd.ir.Ast.MethodCall;
import cd.ir.Ast.MethodDecl;
import cd.ir.Ast.NewArray;
import cd.ir.Ast.NewObject;
import cd.ir.Ast.NullConst;
import cd.ir.Ast.ThisRef;
import cd.ir.Ast.UnaryOp;
import cd.ir.Ast.UnaryOp.UOp;
import cd.ir.Ast.Var;
import cd.ir.Ast.WhileLoop;
import cd.ir.AstVisitor;
import cd.ir.ExprVisitor;

public class AstCodeGenerator {

	protected final ExprGenerator eg = new ExprGenerator();
	protected final StmtDeclGenerator sdg = new StmtDeclGenerator();
	protected final Writer out;
	protected final Main main;
	
	protected CompilerData compilerData = new CompilerData();
	protected RegisterManager registerManager = new RegisterManager();
	protected RegisterCountUpdater registerCountUpdater = new RegisterCountUpdater();

	public AstCodeGenerator(Main main, Writer out) {
		this.out = out;
		this.main = main;
	}

	public void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into three sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link #emitPrologue()}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * <li>Epilogue: Generated by {@link #emitEpilogue()}. This contains any
	 * final declarations required.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
		
		registerManager.reset();
		
		for (ClassDecl ast : astRoots) {
			sdg.gen(ast);
		}
		
		compilerData.emit(this);


	}

	/**
	 * Generates code to evaluate expressions. After emitting the code, returns
	 * a String which indicates the register where the result can be found.
	 */
	protected class ExprGenerator extends ExprVisitor<String, Void> {

		public String gen(Expr ast) {
			return visit(ast, null);
		}

		@Override
		public String visit(Expr ast, Void arg) {

			try {
				emitIndent("Emitting " + AstOneLine.toString(ast));
				return super.visit(ast, null);
			} finally {
				emitUndent();
			}
		}

		@Override
		public String binaryOp(BinaryOp ast, Void arg) {
			
			String leftReg;
			String rightReg;
			
			if (registerCountUpdater.getCount(ast.left()) >= registerCountUpdater.getCount(ast.right()))
			{
				leftReg = visit(ast.left(), null);
				rightReg = visit(ast.right(), null);
			}
			else
			{
				rightReg = visit(ast.right(), null);
				leftReg = visit(ast.left(), null);
			}
			
			switch (ast.operator)
			{
				case B_AND:
					throw new RuntimeException("Not required");
				case B_TIMES:					
					emitComment("mul...");
					emit("imull", "%"+leftReg, "%"+rightReg);
					registerManager.freeRegister(leftReg);
					return rightReg;
				case B_MINUS:					
					emitComment("sub...");
					emit("subl", "%"+rightReg, "%"+leftReg);
					registerManager.freeRegister(rightReg);
					return leftReg;
				case B_PLUS:					
					emitComment("add...");
					emit("addl", "%"+leftReg, "%"+rightReg);
					registerManager.freeRegister(leftReg);
					return rightReg;
				case B_DIV:
					emitComment("div...");
					
					// put left arg to eax
					boolean leftSwap = false;
					if (!leftReg.equals("eax"))
					{
						emit("xchg", "%eax", "%"+leftReg);
						leftSwap = true;
					}
					emit("movl", "%eax", "%edx");
					emit("sarl", c(31), "%edx");
					if (rightReg.equals("edx"))
					{
						emit("idivl", "(%esp)");
					}
					else
					{
						emit("idivl", "%"+rightReg);
					}
					
					emit("popl", "%edx");
					
					if (leftSwap)
					{
						emit("xchg", "%eax", "%"+leftReg);
					}
					
					registerManager.freeRegister(rightReg);
					return leftReg;
					
			}
			return null;	
		}

		@Override
		public String booleanConst(BooleanConst ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String builtInRead(BuiltInRead ast, Void arg) {

			String label = compilerData.stringConstants.constantLabel("%d");
			String register = registerManager.getRegister();
			emit("andl", c(-16), "%esp");
			emit("subl", c(32), "%esp");
			emit("leal", o(28,"%esp"),"%" + register);
			emit("movl", "%" + register, "4(%esp)");
			emit("movl", c(label), "(%esp)");
			emit("call", Config.SCANF);
			emit("movl", o(28,"%esp"), "%"+ register);
			return register;
		}

		@Override
		public String cast(Cast ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String index(Index ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String intConst(IntConst ast, Void arg) {

			String register = registerManager.getRegister();	
			emit("movl", c(ast.value), "%"+register);
			
			return register;
		}

		@Override
		public String field(Field ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String newArray(NewArray ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String newObject(NewObject ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String nullConst(NullConst ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String thisRef(ThisRef ast, Void arg) {
			throw new RuntimeException("Not required");
		}

		@Override
		public String unaryOp(UnaryOp ast, Void arg) {
			
			String reg;
			
			switch (ast.operator)
			{
				case U_PLUS:
					return visit(ast.arg(), null);
				case U_MINUS:
					reg = visit(ast.arg(), null);
					emitComment("negation...");
					emit("negl", "%"+reg);
					return reg;
				case U_BOOL_NOT:
					reg = visit(ast.arg(), null);
					emitComment("not...");
					emit("not", "%"+reg);
					return reg;
			}
			return null;
		}

		@Override
		public String var(Var ast, Void arg) {
			String reg = registerManager.getRegister();
			String label = compilerData.integerVariables.getLabel(ast.name);
			emit("movl", ""+label+"", "%"+reg);
			return reg;
		}
	}

	/**
	 * Generates code to process statements and declarations.
	 */
	public class StmtDeclGenerator extends AstVisitor<String, Void> {

		public void gen(Ast ast) {
			visit(ast, null);
		}

		@Override
		public String visit(Ast ast, Void arg) {
			try {
				emitIndent("Emitting " + AstOneLine.toString(ast));
				return super.visit(ast, arg);
			} finally {
				emitUndent();
			}
		}
				
		@Override
		public String methodCall(MethodCall ast, Void dummy) {
			throw new RuntimeException("Not required");

		}

		@Override
		public String methodDecl(MethodDecl ast, Void arg) {
			// Because we only handle very simple programs in A1,
			// you can just emit the prologue here!
			
			emit(Config.TEXT_SECTION);
			emit(".globl " + Config.MAIN);
			emitLabel(Config.MAIN);
			emitIndent(null);
			emit("pushl","%ebp");
			emit("movl", "%esp","%ebp");
			
			for(int i = 0; i < ast.children().size(); i++) {
				
				visit(ast.children().get(i), null);
			}
			
			emit("movl", c(0), "%eax");
			emit("leave");
			emit("ret");
			emitUndent();

			return null;
		}

		@Override
		public String ifElse(IfElse ast, Void arg) {
			
			throw new RuntimeException("Not required");
		}

		@Override
		public String whileLoop(WhileLoop ast, Void arg) {

			throw new RuntimeException("Not required");
		}

		@Override
		public String assign(Assign ast, Void arg) {		
			
			String result = eg.gen(ast.right());
			String label = compilerData.integerVariables.getLabel(((Var)ast.left()).name);
			emit("movl", "%"+result, ""+label+"");

			registerManager.freeRegister(result);
			
			return null;
		}

		@Override
		public String builtInWrite(BuiltInWrite ast, Void arg) {

			String label = compilerData.stringConstants.constantLabel("%d");
			String register = eg.visit((Expr)ast.children().get(0),null);

			emit("andl", c(-16), "%esp");
			emit("subl", c(16), "%esp");
			emit("movl", "%"+register, "4(%esp)");
			emit("movl", c(label), "(%esp)");
			emit("call", Config.PRINTF);
			
			registerManager.freeRegister(register);
			
			return null;
		}

		@Override
		public String builtInWriteln(BuiltInWriteln ast, Void arg) {
			
			String label = compilerData.stringConstants.constantLabel("\\n");
			
			emit("andl", c(-16), "%esp");
			emit("subl", c(16), "%esp");
			emit("movl", c(label), "(%esp)");
			emit("call", Config.PRINTF);
			
			return null;
		}

	}

	// -------------------------------------------------------
	// EMIT CODE

	private StringBuilder indent = new StringBuilder();

	/** Creates an constant operand relative to another operand. */
	protected String c(int i) {
		return "$" + i;
	}

	/** Creates an constant operand with the address of a label. */
	protected String c(String lbl) {
		return "$" + lbl;
	}

	/** Creates an operand relative to another operand. */
	protected String o(int offset, String reg) {
		return String.format("%d(%s)", offset, reg);
	}

	/** Creates an operand addressing an item in an array */
	protected String a(String arrReg, String idxReg) {
		final int offset = Config.SIZEOF_PTR; // one word in front for vptr
		final int mul = Config.SIZEOF_PTR; // assume all arrays of 4-byte elem
		return String.format("%d(%s,%s,%d)", offset, arrReg, idxReg, mul);
	}

	protected void emitIndent(String comment) {
		this.indent.append("  ");
		if (comment != null)
			emitComment(comment);
	}

	protected void emitCommentSection(String name) {
		int indentLen = this.indent.length();
		int breakLen = 68 - indentLen - name.length();
		StringBuffer sb = new StringBuffer();
		sb.append(Config.COMMENT_SEP).append(" ");
		for (int i = 0; i < indentLen; i++)
			sb.append("_");
		sb.append(name);
		for (int i = 0; i < breakLen; i++)
			sb.append("_");

		try {
			out.write(sb.toString());
			out.write("\n");
		} catch (IOException e) {
		}
	}

	protected void emitComment(String comment) {
		emit(Config.COMMENT_SEP + " " + comment);
	}

	protected void emitUndent() {
		this.indent.setLength(this.indent.length() - 2);
	}

	protected void emit(String op, String src, String dest) {
		emit(String.format("%s %s, %s", op, src, dest));
	}

	protected void emit(String op, String dest) {
		emit(op + " " + dest);
	}

	private int counter = 0;

	protected String uniqueLabel() {
		String labelName = "label" + counter++;
		return labelName;
	}

	protected void emitLabel(String main) {
		try {
			out.write(main + ":" + "\n");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	protected void emit(String op) {
		try {
			out.write(indent.toString());
			out.write(op);
			out.write("\n");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

}
